<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .container {
            width: 800px;
            height: 650px;
            margin: auto;
        }
        .asideRegist {
            width: 150px;
            height: 100%;
            float: left;
            background-color: aliceblue;
        }
        .content {
            width: 500px;
            height: 100%;
            float: left;
            background-color: antiquewhite;
        }
        .header {
            width: 500px;
            height: 50px;
            background-color: azure;
        }
        .list {
            width: 500px;
            height: 600px;
            background-color: beige;
        }
        .asideDetail {
            width: 150px;
            height: 100%;
            float: left;
            background-color: bisque;
        }
        .asideRegist input, .asideDetail input{
            width: 80%;
        }
    </style>
    <script>
        // 가입 폼에서 등록할 한 사람의 정보를 먼저 1차원 배열에 담고,
        // 회원의 목록을 보관하기 위해 또 하나의 큰 배열에다가 생성된 1차원 배열을 추가한다.
        // 결국 배열에 또 다른 배열을 추가했으므로, 표 형태의 2차원 배열이 완성된다.
        // 즉, 배열로 메모리 데이터베이스가 완성된다.
        let memberList = new Array(); // js 에서는 배열 크기를 정하지 않아도 된다.
        // 현재까지는 1차원 배열. 여기서 첫 회원의 배열이 추가되면, 그 때 2차원 배열이 되는 것.
        function regist() {
            let member = new Array(3);  // id, pw, 이름이 들어갈 3칸짜리 비어있는 배열을 선언.
            member[0] = document.getElementById("id").value;
            member[1] = document.getElementById("pwd").value;
            member[2] = document.getElementById("name").value;

            // 한 사람의 정보를 담은 member 배열을, 회원들의 정보를 모아놓을 memberList 배열에 push 하면 된다.
            memberList.push(member);  // push는 java로 치면 java.util.List의 add()
            // console.log(`현재까지 누적된 회원은 ${memberList.length}명 입니다.`);
            console.log(memberList);
            getList();
            
            // 입력했던 회원가입 정보들(텍스트 박스) 초기화
            // 메모리에 올라 온 DOM 객체를 접근하는 방법들은 여러가지가 있는데
            // document.getElementById(), document.querySelector() 등
            // HTML의 부모 자식 관계는, DOM 요소에도 영향을 미친다.
            document.getElementById("id").value="";
            document.getElementById("pwd").value="";
            document.getElementById("name").value="";

        }
        // 회원의 목록을 출력하는 함수. 함수로 정의하는 이유는 회원의 목록은 가입, 삭제, 수정 등 수시로 실행할 코드이다.
        // 즉, 재사용성이 높은 코드이므로 함수로 정의하는게 유리하다.
        function getDetail(v1, v2, v3) {  // 가입 목록에서 선택한 유저에 대한 자세한 정보를 우측 영역에 출력해보자.
            document.querySelector('#id2').value=v1;
            document.querySelector('#pwd2').value=v2;
            document.querySelector('#name2').value=v3;
        }
        function getList() {
            // 문서 내의 .list 라는 클래스명을 갖는 div에 동적으로 table 태그를 출력하자.
            let list = document.querySelector(".list");

            let tag = "";   // List 에 출력할 태그를 모아놓을 변수를 지정.
            tag += "<table border=\"1\" width=\"100%\">";    // 문자열을 누적시켜야 한다.
            tag += "<thead>";
            tag += "<tr>";
            tag += "<th>Id</th>";
            tag += "<th>Pwd</th>";
            tag += "<th>Name</th>";
            tag += "</tr>";
            tag += "</thead>";
            tag += "<tbody>";
            for (i=0 ; i<memberList.length ; i++) {
                tag += "<tr onMouseOver='this.style.background=\"azure\"; this.style.cursor=\"pointer\"' onMouseOut='this.style.background=\"none\"' onclick='getDetail(\""+memberList[i][0]+"\",\""+memberList[i][1]+"\",\""+memberList[i][2]+"\")'>";
                    // this: mouseover 이벤트를 발생시킨 주체 tr DOM 을 의미.
                tag += `<td> ${memberList[i][0]}</td>`;
                tag += `<td> ${memberList[i][1]}</td>`;
                tag += `<td> ${memberList[i][2]}</td>`;
                tag += "</tr>";
            }
            tag += "</tbody>";
            tag += "</table>";
            
            list.innerHTML=tag; // tag에 누적된 문자열을 한 번에 적용하기
        }
        // 태그에 직접 이벤트 핸들러를 연결해도 되지만, 만일 태그가 사라지면 코드도 사라지므로
        // 가급적 이벤트 연결은 프로그래밍 언어로 처리한다.

        // 이벤트 구현 시 사용되는 이름없는 익명 함수의 역할을 콜백(CallBack) 함수라 한다.
        // Call Back - 일반적으로 함수는 개발자가 원하는 시점에 직접 호출하여 사용한다.
        //             하지만 콜백 함수는 특정 이벤트나 조건이 발생했을 때,
        //             시스템이 개발자가 정의해 놓은 함수를 역으로 호출해준다. 말 그대로 콜백.
        function init() {
            let btRegist=document.querySelector(".asideRegist button");
            btRegist.addEventListener("click", function() { // 이게 콜백함수
                // window.alert("나 누름?");
                // 한 사람에 대한 정보를 담을 함수 호출
                regist();
            });
        }
        
        // js 전역 영역은 js 의 window 객체로 표현됨
        // 위, 아래 코드에서 window는 생략 가능하다. 당연하기 때문. 그래서 모두 다 생략하고 쓴다.

        window.addEventListener("load", function(){
            init();
        });

    </script>
</head>
<body>
    <div class="container">
        <div class="asideRegist">
            <form name="form1">    <!-- 정보를 보내기 위한 태그 form. -->
                <input type="text" placeholder="Your ID" id="id">
                <input type="password" placeholder="Your Password" id="pwd">
                <input type="text" placeholder="Your Name" id="name">
                <!-- 버튼은 타입을 명시하지 않고 form 태그에 넣으면 모든 요소를 서버로 전송한다.
                     그래서 새로고침 효과가 나타난다. 따라서 button의 type을 button으로 명시해야 한다. -->
                <button type="button">가입</button> 
            </form>
        </div>
        <div class="content">
            <div class="header">

            </div>
            <div class="list">
                
            </div>
        </div>
        <div class="asideDetail">
            <input type="text" placeholder="Your ID" id="id2">
            <input type="text" placeholder="Your Password" id="pwd2">
            <input type="text" placeholder="Your Name" id="name2">
            <button>삭제</button>
            <button>수정</button>
        </div>
    </div>
</body>
</html>